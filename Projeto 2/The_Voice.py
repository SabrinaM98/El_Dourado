# -*- coding: utf-8 -*-
"""The_voice.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1HKUp3uGtuFFXfaZOxkZSyF6ik7rn3pPO

## **Usando aúdio do seu microfone por meio do Colab para usá-lo com API's da IBM **
"""

!pip install ffmpeg-python

from IPython.display import HTML, Audio
from google.colab.output import eval_js
from base64 import b64decode
import numpy as np
from scipy.io.wavfile import read as wav_read
import io
import ffmpeg

def get_audio():
  display(HTML(AUDIO_HTML))
  data = eval_js("data")
  binary = b64decode(data.split(',')[1])
  
  process = (ffmpeg
    .input('pipe:0')
    .output('pipe:1', format='wav')
    .run_async(pipe_stdin=True, pipe_stdout=True, pipe_stderr=True, quiet=True, overwrite_output=True)
  )
  output, err = process.communicate(input=binary)
  
  riff_chunk_size = len(output) - 8
  # Break up the chunk size into four bytes, held in b.
  q = riff_chunk_size
  b = []
  for i in range(4):
      q, r = divmod(q, 256)
      b.append(r)

  # Replace bytes 4:8 in proc.stdout with the actual size of the RIFF chunk.
  riff = output[:4] + bytes(b) + output[8:]

  sr, audio = wav_read(io.BytesIO(riff))

  return audio, sr

audio, sr = get_audio()

from scipy.io.wavfile import write

write("testando.wav", sr, audio)

"""## Usando aúdio do microfone"""

!pip install ibm_watson wget

from ibm_watson import SpeechToTextV1 
import json
from ibm_cloud_sdk_core.authenticators import IAMAuthenticator

url_s2t = "https://api.us-south.speech-to-text.watson.cloud.ibm.com/instances/b552f651-24d8-45bb-8564-1e934c9e51ac"
iam_apikey_s2t = "4C1jFpg54OiM8AbrHysCKBU9aii4kSYDyMvNOxcWTabE"
authenticator = IAMAuthenticator(iam_apikey_s2t)
s2t = SpeechToTextV1(authenticator=authenticator)
s2t.set_service_url(url_s2t)
s2t

filename='testando.wav'
with open(filename, mode="rb") as wav:
    response = s2t.recognize(audio=wav, content_type='audio/wav')

response.result

from pandas import json_normalize

json_normalize(response.result['results'],"alternatives")
recognized_text=response.result['results'][0]["alternatives"][0]["transcript"]
type(recognized_text)

json_normalize(response.result['results'],"alternatives")

found_words=recognized_text.split(" ")
print(found_words)

"""# Passando a string do STT para o TTS

Inicialização e autenticação da API TTS (sintetização de voz)
"""

from ibm_watson import TextToSpeechV1

api_key_tts = 'uE5xgRYWFhtHBAnd_5xHLiWXTHMIuUnEq_4CbF7hcg9V'
api_url_tts = 'https://api.us-south.text-to-speech.watson.cloud.ibm.com/instances/5ed0b86c-c03d-4a5a-9c49-5a57edab7846'

authenticator = IAMAuthenticator(api_key_tts)
text_to_speech = TextToSpeechV1(
    authenticator=authenticator
)
text_to_speech.set_service_url(api_url_tts)

"""re-gravando um audio com voz artificial em inglês"""

with open('gravando_dnv.wav', 'wb') as audio_file:
    audio_file.write(
        text_to_speech.synthesize(
            recognized_text,
            voice='en-US_LisaVoice',
            accept='audio/wav'        
        ).get_result().content)

"""# Traduzindo o texto usando API da IBM


"""

from ibm_watson import LanguageTranslatorV3
url_lt='https://api.us-south.language-translator.watson.cloud.ibm.com/instances/2dc74fe5-52da-464c-8f4b-53a595d68b84'
apikey_lt='JZQcIhmebXa8EAD98EGh3501guraxTw1EAhptL8YwGi5'
version_lt='2018-05-01'

authenticatorLT = IAMAuthenticator(apikey_lt)
language_translator = LanguageTranslatorV3(version=version_lt,authenticator=authenticatorLT)
language_translator.set_service_url(url_lt)
language_translator

"""solicitando tradução do inglês para o mandarim"""

translation_response = language_translator.translate(\
    text=recognized_text, model_id='en-zh')
translation_response

translation=translation_response.get_result()

cn_translate =translation['translations'][0]['translation']
cn_translate

"""gravar o aúdio em mandarim"""

with open('teste_gravado_dnv_traduzido.wav', 'wb') as audio_file:
    audio_file.write(
        text_to_speech.synthesize(
            cn_translate,
            voice='zh-CN_ZhangJingVoice',
            accept='audio/wav'        
        ).get_result().content)
